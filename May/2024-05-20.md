## 날짜: 2024-05-20

### 스크럼

-   목표 1 : java 클래스 다이어그램 작성
-   목표 2 : 백준 dp 문제 풀이

### 공부한 내용

### 주제 1: 0/1 Knapsack Problem

<aside>
💡 배낭 문제는 **n개의 물건**과 **각 물건 i의 무게 wi와 가치 vi**가 주어지고, **배낭의 용량이 C**일 때, **배낭에 담을 수 있는 물건의 최대 가치**를 찾는 문제이다.
단, 배낭에 담은 물건의 무게의 합이 C를 초과하지 말아야 하고,
각 물건은 1개씩만 있다고 가정한다.

</aside>

0-1 Knapsack Problem은 넣는다, 안넣는다 두가지 선택지뿐이다.

최대 M을 담을 수 있는 배낭에 무게 N이고 가치가 K인 물건을 담으면?

현재 가치가 K이고 배낭에 최대(M-N) kg 더 넣을 수 있다.이를 다르게 생각해 보면 이렇게도 생각할 수 있다.

무게 N인 물건을 제외하고, 최대(M-N) kg를 담을 수 있는 배낭이 있다.

**이** (M-N)**kg인 배낭과 남은 물건들로 구성된 새로운 문제를 만드는 것이다.**

-   백준 12865 골5
    -   주어진 물건을 순서대로 접근하는 루프와 1부터 담을 수 있는 무게까지 접근하는 루프로 2중 루프 안에서
    -   담을 수 있는 물건이면
        -   현재의 최대 가치 = max(현재 물건 가치 + dp[이전 물건][현재 가방 무게 - 현재 물건 무게], dp[이전 물건][현재 가방 무게])
        -   즉 현재 물건가치 + 견디는무게에서 물건 무게 뺀거 에서 들어가는 물건 무게
    -   담을 수 없는 물건이면, 이전 물건에서 현재 무게의 값
    ```python
    n,k=map(int,input().split())
    bag = [list(map(int, input().split())) for _ in range(n)]
    dp=[[0]*(k+1) for _ in range(n+1)]

    # 물건 수
    for i in range(1,n+1):
        # 버티는 무게
        for j in range(1,k+1):
            w=bag[i-1][0]
            v=bag[i-1][1]
            # 물건을 담을 수 있는 경우
            if j>=w:
                dp[i][j]=max(dp[i-1][j],v + dp[i-1][j-w])
            else:
                dp[i][j]=dp[i-1][j]
    print(dp[n][k])
    ```

### 오늘 한 작업

-   java 클래스 다이어그램 작성
    -   https://github.com/jjikky/clothing-shop-java-cli
-   백준 DP 5문제 풀이

### 오늘의 회고

-   클래스 다이어그램 기반으로 자바 구현을 해야하는데, 백지 상태여서 책으로 하나씩 공부하면서 인내심 있게 공부해야 할 것 같다
