## 날짜: 2024-05-17

### 스크럼

-   목표 1 : OOP, SOLID 개념 정리
-   목표 2 : 리액트 커뮤니티 리팩토링

### 공부한 내용

### 주제 1: OOP

-   **현실 세계의 사물이나 개념을 객체로 표현**하고, 이러한 객체들 간의 상호작용을 통해 프로그램을 구현하는 방법론
-   OOP의 네가지 원칙
    -   캡슐화 ( Encapsulation )
        -   **`외부에 노출할 필요가 없는 정보들은 은닉하고 공개적으로 노출된 방법을 통해서만 액세스`**
        -   관련이 있는 변수와 함수를 하나의 클래스로 묶고 접근제어자를 활용하여 외부에 노출할 필요가 없는 정보들을 은닉
        -   객체의 직접적인 접근을 막고 외부에서 내부의 정보에 직접접근하거나 변경할 수 없고 객체가 제공하는 필드와 메소드를 통해서만 접근이 가능합니다.
        -   캡슐화 구현방법
            -   `**접근 제어자`\*\* 활용
            -   `**getter / setter`\*\* 활용
                -   Getter 메서드는 필드 값을 반환합니다.
                -   Setter 메서드를 사용하면 간접적이지만 허용되는 방식으로 필드 값을 변경할 수 있습니다.
    -   추상화 ( Abstraction )
        -   상속은 클래스 간 공유될 수 있는 속성과 기능들을 상위 클래스로 추상화 시켜 해당 **상위 클래스로부터 확장된 여러 개의 하위 클래스들이 모두 상위 클래스의 속성과 기능들을 간편하게 사용**할 수 있도록 합니다.
        즉, 클래스들 간 공유하는 속성과 기능들을 반복적으로 정의할 필요 없이 딱 한 번만 정의해두고 간편하게 **재사용 !**
    -   상속 ( Inheritance )
        -   **`기존의 클래스를 재활용하여 새로운 클래스를 작성하는 자바의 문법 요소`**
        -   상속은 클래스 간 공유될 수 있는 속성과 기능들을 상위 클래스로 추상화 시켜 해당 **상위 클래스로부터 확장된 여러 개의 하위 클래스들이 모두 상위 클래스의 속성과 기능들을 간편하게 사용**할 수 있도록 합니다
        -   즉, 클래스들 간 공유하는 속성과 기능들을 반복적으로 정의할 필요 없이 딱 한 번만 정의해두고 간편하게 **재사용 !**
    -   다형성 ( Polymorphism )
        -   객체 지향에서의 다형성도 이와 비슷합니다. 즉, **어떤 객체의 속성이나 기능이 그 맥락에 따라 다른 역할을 수행할수 있는 객체 지향의 특성**을 의미합니다.
        -   대표적인 예로,**메서드 오버라이딩**과 **메서드 오버로딩(method overloading)**이 있습니다.
            -   오버라이딩: 상위 클래스의 메소드를 하위 클래스에서 재정의하여 사용하는 것
            -   오버로딩: 같은 이름의 메소드를 여러 개 가지면서 매개변수의 유형과 개수가 다르도록 하는 것
        -   메서드 오버라이딩과 메서드 오버로딩도 다형성의 한 중요한 예시지만, 객체 지향의 맥락에서 이것보다 더 중요한 다형성의 정의는 이것입니다.
            -   객체 지향 프로그래밍에서 다형성이란 한 타입의 참조변수를 통해 여러 타입의 객체를 참조할 수 있도록 만든 것을 의미합니다. 좀 더 구체적으로, 상위 클래스 타입의 참조변수로 하위 클래스의 객체를 참조할 수 있도록 하는 것입니다.

### 주제 2: SOLID

-   OCP ( Open Close Prinicple ) : 개방 폐쇄 원칙
    -   클래스는 '확장에 열려있어야 하며, 수정에는 닫혀있어야 한다' 를 뜻한다.
        -   [ 확장에 열려있다 ] - 새로운 변경 사항이 발생했을 때 유연하게 코드를 추가함으로써 큰 힘을 들이지 않고 애플리케이션의 기능을 확장할 수 있음
        -   [ 변경에 닫혀있다 ] - 새로운 변경 사항이 발생했을 때 객체를 직접적으로 수정을 제한함.
    -   OCP 원칙은 **추상화와 상속**을 통한 클래스 관계 구축을 권장을 의미하는 것
-   LSP ( Liskov Substitution Principle ) : 리스코프 치환 원칙
    -   서브 타입은 언제나 기반(부모) 타입으로 교체할 수 있어야 한다는 원칙
    -   다형성의 특징을 이용하기 위해 상위 클래스 타입으로 객체를 선언하여 하위 클래스의 인스턴스를 받으면, \*업캐스팅된 상태에서 부모의 메서드를 사용해도 동작이 의도대로 흘러가야 하는 것을 의미하는 것
        \*업캐스팅 : 객체를 상위 클래스 타입으로 변환하는 것
        하위 클래스의 인스턴스를 상위 클래스 타입의 변수에 할당할 때 업캐스팅이 발생
        -   예시 코드
            ```java
            class Animal {
                void sound() {
                    System.out.println("Animal makes a sound");
                }
            }

            class Dog extends Animal {
            		@override
                void sound() {
                    System.out.println("Dog barks");
                }
            }

            public class Main {
                public static void main(String[] args) {
                    Animal myAnimal = new Dog(); // 업캐스팅
                    myAnimal.sound(); // Dog의 sound() 메서드가 호출됨
                }
            }
            ```
            **`myAnimal`**은 **`Animal`** 타입으로 선언되었지만 **`Dog`** 인스턴스를 참조하고 있습니다. 이 상태가 업캐스팅된 상태입니다.
            이 상태에서도 메서드 호출이 의도한 대로 하위 클래스에서 오버라이딩된 메서드가 실행된다는 것을 뜻합니다.
    -   한마디로 다형성 이용을 위해 부모 타입으로 메서드를 실행해도 의도대로 실행되도록 구성을 해줘야 하는 원칙
-   ISP ( Interface Segregation Principle ) : 인터페이스 분리 원칙
    -   인터페이스를 각각 사용에 맞게 끔 잘게 분리해야한다는 설계 원칙
    -   SRP 원칙이 클래스의 단일 책임을 강조한다면, ISP는 인터페이스의 단일 책임을 강조
    -   SRP 원칙의 목표는 클래스 분리를 통 이루어진다면, ISP 원칙은 인터페이스 분리를 통해 설계
    -   인터페이스는 제약 없이 자유롭게 다중 상속(구현)이 가능하기 때문에, 분리할 수 있으면 분리하여 각 클래스 용도에 맞게 implements 하라는 설계 원칙이라고 이해하면 된다.
-   DIP ( Dependency Inversion Principle ) : 의존 역전 원칙
    -   어떤 Class를 참조해서 사용해야하는 상황이 생긴다면, 그 Class를 직접 참조하는 것이 아니라 그 대상의 상위 요소(추상 클래스 or 인터페이스)로 참조하라는 원칙
    -   구현 클래스에 의존하지 말고, 인터페이스에 의존하라는 뜻
    -   의존 역전 원칙의 지향점은 각 클래스간의 결합도(coupling)을 낮추는 것

### 오늘의 도전 과제와 해결 방법

### 오늘 한 작업

-   OOP, SOLID 개념 정리
-   리액트 커뮤니티 리팩토링
    -   게시글 조회 - 댓글 등록 수정 로직 변경
    -   댓글수 가져오는 방법 변경

### 오늘의 회고

-   구현시간만큼 프로젝트 개발 내용을 기록하는 것에도 많은 시간을 투자해야겠다.
