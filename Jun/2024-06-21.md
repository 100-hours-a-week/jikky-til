## 날짜: 2024-06-21

### 공부한 내용

### 주제 1: JPA 트랜잭션과 락 ( 동시성 제어 )

JPA(Java Persistence API)는 자바에서 객체-관계 매핑(ORM)을 위한 표준 명세

JPA를 사용할 때, **트랜잭션과 락은 데이터의 일관성을 유지하고 동시성을 관리하기 위해 중요한 역할**을 합니다.

각각에 대해 알아보겠습니다.

# JPA 트랜잭션

트랜잭션은 데이터베이스 연산의 논리적 단위

JPA에서는 **트랜잭션을 통해 데이터의 일관성과 무결성을 보장**합니다.

트랜잭션은 다음과 같은 특성을 가집니다:

1. **Atomicity (원자성)**: 트랜잭션 내의 모든 연산은 모두 성공하거나 모두 실패해야 합니다. 중간에 실패하면 모든 변화는 원래 상태로 되돌림
2. **Consistency (일관성)**: 트랜잭션이 완료되면 데이터는 일관된 상태를 유지해야 함
3. **Isolation (고립성)**: 하나의 트랜잭션이 완료될 때까지 다른 트랜잭션이 영향을 받지 않도록 보장
4. **Durability (지속성)**: 트랜잭션이 성공적으로 완료되면 그 결과는 영구적으로 저장

JPA에서 트랜잭션을 관리하려면 `@Transactional` 어노테이션을 사용하거나, EntityManager의 `begin`, `commit`, `rollback` 메소드를 사용하여 명시적으로 트랜잭션을 제어할 수 있다.

```java
import javax.persistence.EntityManager;
import javax.persistence.EntityTransaction;

public void someMethod() {
    EntityManager em = entityManagerFactory.createEntityManager();
    EntityTransaction tx = em.getTransaction();

    try {
        tx.begin();
        // 비즈니스 로직
        tx.commit();
    } catch (RuntimeException e) {
        tx.rollback();
        throw e;
    } finally {
        em.close();
    }
}
```

## 격리 수준

트랜잭션은 원자성, 일관성, 지속성을 보장하지만 문제는 격리성이다. 트랜잭션간 완전한 격리를 보장하기 위해서는 동시성 측면에서 많은 손해를 본다.

락(Lock)을 이해하기 전에 트랜잭션 격리 수준을 먼저 알아야한다.

트랜잭션 격리수준(isolation level)이란 동시에 여러 트랜잭션을 처리할 때, 트랜잭션이 얼마나 서로 고립되어 있는지를 의미한다.

즉, **해당 트랜잭션이 다른 트랜잭션에서 변경한 데이터를 볼 수 있는 기준**을 결정하는 것

- **`READ UNCOMMITTED`**
  - 커밋되지 않은 데이터를 읽을 수 있다.
  - Dirty Read, Dirty Write가 발생할 수 있다.
- **`READ COMMITTED`**
  - 커밋된 데이터만 읽을 수 있다.
  - 오라클 DBMS에서 표준으로 사용하고 있고 가장 많이 선택된다.
  - Lost Update, Write Skew, Read Skew가 발생할 수 있다.
- **`REPETABLE READ`**
  - MySQL에서는 트랜잭션마다 트랜잭션 ID를 부여하여 트랜잭션 ID보다 작은 트랜잭션 번호에서 변경한 것만 읽게 된다.
  - Undo 공간에 백업해두고 실제 레코드 값을 변경한다.
    - Undo에 백업된 데이터는 주기적으로 삭제한다.
  - Phantom Read가 발생할 수 있다.
    - 다른 트랜잭션에서 수행한 변경 작업에 의해 레코드가 보였다가 안 보였다가 하는 현상
    - Undo를 사용해서 시점을 보장하지만, 새로 삽입된 레코드는 Undo가 없기 때문
    - InnoDB에서는 트랜잭션 id를 이용해서 Phantom Read 문제를 해결한다!
- **`SERIALIZABLE`**
  - 모든 트랜잭션을 순서대로 실행한다.

격리 수준이 높아질수록 자원을 많이 사용하고 성능이 떨어진다. 일반적으로는 **`READ COMMITTED`**나 **`REPEATABLE READ`** 중 하나를 사용한다.

JPA를 사용하면 **`READ COMMITTED`** 이상의 격리 수준이 필요할 때 비관적 락, 낙관적 락을 선택해야 한다.

### 두 번의 갱실 분제

트랜잭션 격리 수준으로는 해결할 수 없는 **두 번의 갱실 분실 문제**가 존재한다.

- 유저1과 유저2는 동시에 수정 화면에 진입했고, 내용을 수정한 뒤, 수정 버튼을 클릭했다.
- 유저1의 트랜잭션이 먼저 커밋되고, 유저2의 트랜잭션이 커밋되었다.
- 이 경우 유저 1의 트랜잭션 변경 내용은 사라지게 되고, 유저 2의 트랜잭션 만이 db에 반영된다

이 때 3가지 처리 방법이 있다.

1. 마지막 커밋만 인정 : 유저 1 무시, 유저2 내용 반영
2. 최초 커밋만 인정 : 유저 1이 수정 완료 했으므로, 유저2 변경에 대해 오류 발생
3. 충돌 내용병합 : 두 변경사항을 병합

상황에 따라 위 3가지중 하나의 방법을 선택해야 하지만

트랜잭션의 격리수준으로는 **`마지막 커밋만 인정`** 외의 정책 구현이 **불가**하다

아래에서 추가로 알아보자

# JPA 락 (Lock)

**락**은 트랜잭션이 데이터를 읽거나 쓰는 동안 다른 트랜잭션이 그 데이터에 접근하지 못하게 하는 메커니즘

JPA에서 락은 동시성 문제를 해결하기 위해 사용된다. 일반적으로 두 가지 락 모드가 있다

## **Optimistic Locking (낙관적 락)**

- 대부분의 트랜잭션이 충돌이 발생하지 않을 것이라고 **낙관적으로 가정**하는 방법
  - 여러 트랜잭션이 동일한 데이터를 읽을 수 있도록 **허용**하지만, 데이터를 수정할 때는 **데이터가 변하지 않았음을 확인**
- 따라서 데이터베이스가 제공하는 락 기능을 사용하지 않고, 엔티티의 버전을 통해 동시성을 제어
  - 즉, 어플리케이션 레벨에서 지원하는 락
  - 주로 `@Version` 어노테이션을 사용하여 버전 관리를 통해 충돌을 감지
  - **@Version** 적용이 가능한 타입은 Long(long), Integer(int), Short(short), Timestamp
    ```java
    @Entity
    public class Board {

      @Id
      private String id;
      private String title;

      @Version
      private Integer version;
    }
    ```
    위 **`Board`** 엔티티가 변경될 때 마다 **`version`** 이 자동으로 하나씩 증가
    그리고 엔티티를 수정할 때, 엔티티를 조회한 시점의 버전과 수정한 시점의 버전이 일치하지 않으면 예외가 발생
    - **버전 정보 비교 방법**
      JPA가 엔티티를 수정하고 트랜잭션을 커밋하는 시점에, 영속성 컨텍스트를 flush 하면서 아래의 **`UPDATE`** 쿼리를 실행
      ```java
      UPDATE BOARD
      SET
        title = ?,
        version = ? # 버전 + 1 증가
      WHERE
        id = ?,
        and version = ? # 버전 비교
      ```
      위와 같이 데이터가 수정되었을 때, 엔티티의 버전 정보를 증가시킨다. 위 쿼리에서 **`WHERE`** 절에서 엔티티 조회 시점의 버전으로 데이터를 찾는 조건을 볼 수 있다. 만약 데이터 조회 이후 **엔티티가 수정되었다면 위 `WHERE` 문으로 엔티티를 찾을 수 없다**. 이 때 JPA가 예외를 던진다.
      주의⚠️
      **`@Version`** 으로 추가한 버전 관리 필드는 JPA가 직접 관리하므로 임의로 수정해서는 안된다.
    - **예시 - 두번의 갱신 분실 문제  (second lost updates problem)**
      - 계좌에 10000원이 있고, 트랜잭션1이 1,000원 트랜잭션2가 5,000원 입금하는 상황
      - t1 시작 → 잔액 10,000읽음 → 근소한 차이로 t2 시작하며 잔액 10,000읽음
      - t1 이 잔액+1,000 = 15,000 커밋함 → 엔티티가 v2가 됨
      - t2가 엔티티를 수정하고 커밋하려함 → t2가 조회한 시점에는 v1이었는데, 수정하는 시점에서는 v2임 → 버전의 불일치로 예외 발생

### **낙관적 락의 LockModeType**

LockModeType을 통해서 락 옵션을 변경할 수 있다.

- **NONE**
  - 엔티티에 **`@Version`** 을 적용하면 기본으로 적용되는 락 옵션
  - **용도** : 조회한 엔티티를 수정하는 시점에 다른 트랜잭션으로부터 변경(또는 삭제)되지 않음을 보장한다. 즉, 조회 시점부터 수정 시점까지를 보장한다.
  - **동작** : 엔티티를 수정하는 시점에 엔티티의 버전을 증가시킨다. 이때 엔티티의 버전이 조회 시점과 다르다면 예외가 발생한다.
  - **이점** : 두 번의 갱신 분실 문제를 해결한다.
- **OPTIMISTIC**
  - **`NONE`** 의 경우 엔티티를 수정해야 버전을 체크하지만, 이 옵션은 엔티티를 **조회만 해도 버전을 체크**한다. 즉, 한번 조회한 엔티티가 트랜잭션 동안 변경되지 않음을 보장
  - **용도** : 엔티티의 조회 시점부터 트랜잭션이 끝날 때 까지 다른 트랜잭션에 의해 변경되지 않음을 보장한다.
  - **동작** : 트랜잭션을 커밋하는 시점에 버전정보를 체크한다.
  - **이점** : 애플리케이션 레벨에서 DIRTY READ와 NON-REPEATABLE READ를 방지한다.
- **OPTIMISTIC*FORCE*INCREMENT**
  낙관적 락을 사용하면서 **버전 정보를 강제로 증가**한다. 엔티티가 물리적으로 변경되지 않았지만, **논리적으로는 변경**되었을 경우 **버전을 증가하고 싶을 때 사용**한다.
  예를 들어 게시물과 첨부파일 엔티티가 1:N 관계로 있다고 가정하자. 게시물에 첨부파일이 하나 추가된 상황은 게시물 엔티티의 물리적 변경은 일어나지 않았지만, 논리적인 변경은 일어났다. 이때 버전을 변경하고 싶다면 해당 락 옵션을 사용하면 된다.
  - 용도 : 논리적인 단위의 엔티티 묶음을 관리할 수 있다.
  - 동작 : 엔티티가 직접적으로 수정되어 있지 않아도, 트랜잭션을 커밋할 때 UPDATE 쿼리를 사용해 버전 정보를 강제로 증가시킨다. 이때 엔티티의 버전을 체크하고 일치하지 않으면 예외가 발생한다. 이때 추가로 엔티티의 정보도 실제로 변경되었다면 2번의 버전 증가가 발생한다.
  - 이점 : 강제로 버전을 변경하여 논리적인 단위의 엔티티 묶음을 버전관리할 수 있다.

### 낙관적 락 장단점

낙관적 락은 주로 읽기 작업이 많은 환경에서 유용

- **장점 :** 락을 사용하지 않기 때문에 동시성이 높아진다
- **단점**: 데이터 충돌이 발생할 경우 롤백이 필요하다

---

## **Pessimistic Locking (비관적 락)**

- 대부분의 트랜잭션이 충돌이 발생할 것이라고 비**관적으로 가정**하는 방법
- 데이터베이스의 락을 사용하여 동시성을 제어
  - 데이터를 읽을 때 다른 트랜잭션이 해당 **데이터를 수정하지 못하도록 잠급니다**.
  - 데이터 수정시 즉시 트랜잭션 충돌 여부 확인 가
- `EntityManager`의 `lock` 메소드나 `@Lock` 어노테이션을 사용하여 비관적 락을 걸 수 있다.
  ```java
  import javax.persistence.LockModeType;

  public void someMethod() {
      EntityManager em = entityManagerFactory.createEntityManager();
      em.getTransaction().begin();

      Person person = em.find(Person.class, 1L, LockModeType.PESSIMISTIC_WRITE);
      // 데이터 수정
      em.getTransaction().commit();
  }
  ```
  ```java
  public interface UserRepository extends JpaRepository<User, Long> {
      @Lock(LockModeType.PESSIMISTIC_WRITE)
      @Query("select b from User b where b.id = :id")
      User findByIdForUpdate(Long id);
  }
  ```

### **비관적 락의 LockModeType**

**PESSIMISTIC_WRITE**

- 다른 트랜잭션에서 읽기도 못하고 쓰기도 못함
- 비관적 락이라고 하면 **일반적으로 해당 옵션**을 의미

**PESSIMISTIC_READ**

- 다른 트랜잭션에서 읽기만 가능

**PESSIMISTIC*FORCE*INCREMENT**

- 다른 트랜잭션에서 읽기도 못하고 쓰기도 못함 + 추가적으로 버저닝을 수행

비관적 락 중 유일하게 **버전 정보를 사용**한다. 비관적 락이지만 버전 정보를 강제적으로 증가시킨다.

### 비관적 점

비관적 락은 주로 쓰기 작업이 많은 환경에서 유용하다

- **장점**: 데이터 충돌을 미리 방지할 수 있다.
- **단점**: 락으로 인한 성능 저하가 발생할 수 있다.
  - 비관적 락은 조회한 레코드 자체에 락을 걸기 때문에 성능이 저하될 수 있다.
  - 성능상 이슈가 발견된다면 낙관적 락을 고려해야 한다.

## **동시성 제어 메커니즘과 트랜잭션 격리 수준의 차이점**

- **JPA의 동시성 제어 메커니즘은 특정 엔티티에 대한 동시 접근을 막기 위해 사용**
- **트랜잭션 격리 수준은 트랜잭션 동안의 일관된 데이터 읽기를 고려하기 위해 적용**

낙관락/비관락은 그 관심사가 엔티티에 대한 동시 접근에 대한 처리이다. 한 트랜잭션이 특정 엔티티에 접근하고 있을 때 다른 트랜잭션이 해당 엔티티를 변경할 수 없도록 버전을 사용하거나 락을 걸어 해결한다. 즉, 트랜잭션 격리 수준과는 관계가 없다.

### 오늘 한 작업

- JPA트랜잭션과 락 공부
- [ 머라카노 ] FE, BE 인증이슈 해결    
  
- 오늘의 작업시간

  ![image](https://github.com/jjikky/jikky-til/assets/59151187/ca5995b8-8ac7-473b-bd60-65906466bb76)

